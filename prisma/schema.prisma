generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model TeamMember {
  id                  String   @id @default(cuid())
  name                String
  email               String?  @unique
  role                String   // "cofounder", "engineer", "freelance"
  hourlyRate          Float?
  monthlyCost         Float?
  weeklyHours         Float    @default(40) // expected hours/week (part-timers < 40)
  isActive            Boolean  @default(true)
  linearUserId        String?
  mercuryCounterparty String?  // Exact counterpartyName from Mercury for 1:1 matching
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  allocations      TimeAllocation[]
  demandForecasts  DemandForecast[]
  meetings         ClientMeeting[]
  payments         EngineerPayment[]
  costAllocations  EngineerCostAllocation[]
  throughputs      EngineerThroughput[]
}

model Customer {
  id              String   @id @default(cuid())
  displayName     String
  spreadsheetName String?
  bankName        String?
  emailDomain     String?  // e.g. "nouri.health" — for matching calendar attendees
  linearProjectId String?
  email           String?
  aliases         String[]
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  salesSnapshots  SalesSnapshot[]
  transactions    BankTransaction[]
  allocations     TimeAllocation[]
  demandForecasts DemandForecast[]
  margins         MonthlyMargin[]
  meetings        ClientMeeting[]
  domainMappings  DomainMapping[]
  costAllocations EngineerCostAllocation[]
}

model DomainMapping {
  id          String    @id @default(cuid())
  domain      String    @unique
  meetingType String    // "client", "sales", "internal", "ignore"
  customerId  String?
  customer    Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model SalesSnapshot {
  id           String   @id @default(cuid())
  customerId   String
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  month        String   // "2026-01"
  snapshotDate DateTime
  amount       Float
  currency     String   @default("USD")
  notes        String?
  createdAt    DateTime @default(now())

  @@unique([customerId, month])
  @@index([snapshotDate])
}

model BankTransaction {
  id               String    @id @default(cuid())
  mercuryId        String    @unique
  customerId       String?
  customer         Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  amount           Float
  currency         String    @default("USD")
  description      String
  counterpartyName String?
  status           String
  postedAt         DateTime?
  createdAt        DateTime  @default(now())
  isReconciled     Boolean   @default(false)
  reconciledMonth  String?
  direction        String    @default("incoming") // "incoming" or "outgoing"
  costCategory     String?   // "labor", "software", "other"

  engineerPayments EngineerPayment[]

  @@index([customerId])
  @@index([postedAt])
  @@index([direction, isReconciled, counterpartyName])
  @@index([direction, costCategory])
  @@index([customerId, isReconciled, reconciledMonth])
}

model DemandForecast {
  id            String      @id @default(cuid())
  customerId    String
  customer      Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)
  teamMemberId  String?
  teamMember    TeamMember? @relation(fields: [teamMemberId], references: [id], onDelete: SetNull)
  weekStart     DateTime    // Monday 00:00 UTC of the target week
  ticketsNeeded Float?      // primary input: number of tickets planned
  hoursNeeded   Float       // derived from tickets × rate, or manual override
  confidence    String?     // "high", "medium", "low"
  notes         String?
  source        String      @default("manual") // "manual", "linear", "carry_forward"
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@unique([customerId, teamMemberId, weekStart])
  @@index([weekStart])
  @@index([teamMemberId, weekStart])
}

model EngineerThroughput {
  id               String     @id @default(cuid())
  teamMemberId     String
  teamMember       TeamMember @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  month            String     // "2026-02"
  billedHours      Float      // manual input: hours worked this month
  completedTickets Int?       // auto-computed from Linear
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@unique([teamMemberId, month])
  @@index([month])
}

model TimeAllocation {
  id           String     @id @default(cuid())
  teamMemberId String
  teamMember   TeamMember @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  customerId   String
  customer     Customer   @relation(fields: [customerId], references: [id], onDelete: Cascade)
  month        String
  week         Int        // 1-5, week number within the month
  percentage   Float
  source       String     @default("manual") // "linear" or "manual"
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([teamMemberId, customerId, month, week])
  @@index([month])
}

model LinearSyncCache {
  id       String   @id @default(cuid())
  month    String   @unique
  syncedAt DateTime
  data     String   // JSON-serialized completed issues
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MonthlyMargin {
  id              String   @id @default(cuid())
  customerId      String
  customer        Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  month           String
  revenue         Float
  engineeringCost Float
  margin          Float
  marginPercent   Float
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([customerId, month])
}

model VendorCategoryRule {
  id            String   @id @default(cuid())
  vendorPattern String   @unique // Substring match against counterpartyName
  category      String   // "labor", "software", "other"
  displayName   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model MonthlyCostSummary {
  id           String   @id @default(cuid())
  month        String   @unique // "2026-01"
  laborCost    Float    @default(0)
  softwareCost Float    @default(0)
  otherCost    Float    @default(0)
  totalCost    Float    @default(0)
  calculatedAt DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model ClientMeeting {
  id              String      @id @default(cuid())
  googleEventId   String      @unique
  meetingType     String      @default("client") // "client", "sales", "internal"
  customerId      String?
  customer        Customer?   @relation(fields: [customerId], references: [id], onDelete: SetNull)
  teamMemberId    String
  teamMember      TeamMember  @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  date            DateTime
  durationMinutes Int
  title           String
  attendeeEmails  String[]
  externalDomains String[]
  syncedAt        DateTime    @default(now())

  @@index([customerId, date])
  @@index([teamMemberId, date])
  @@index([meetingType, date])
}

model ResolutionItem {
  id             String    @id @default(cuid())
  type           String    // "customer_match", "domain_classify", "vendor_categorize", "sheet_customer"
  status         String    @default("pending") // "pending", "auto_resolved", "confirmed", "rejected"
  sourceEntity   String    // The unmatched string (e.g. "Nouri Health Inc", "nouri.health")
  suggestedMatch String?   // JSON: proposed resolution (e.g. { customerId, displayName, confidence })
  confidence     Int       @default(0) // 0-100
  context        String?   // JSON: extra info (amount, date, meeting count, etc.)
  resolvedVia    String?   // "dashboard", "voice", "cli", "slack"
  resolvedAt     DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([type, sourceEntity])
  @@index([status, type])
}

model ResolutionAuditLog {
  id               String   @id @default(cuid())
  resolutionItemId String
  entityType       String   // "BankTransaction", "Customer", "DomainMapping", "VendorCategoryRule"
  entityId         String
  field            String   // e.g. "customerId", "aliases", "costCategory"
  oldValue         String?  // JSON string of previous value
  newValue         String?  // JSON string of new value
  createdAt        DateTime @default(now())

  @@index([resolutionItemId])
}

model EngineerPayment {
  id                String          @id @default(cuid())
  teamMemberId      String
  teamMember        TeamMember      @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  bankTransactionId String
  bankTransaction   BankTransaction @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)
  amount            Float           // Absolute dollar amount attributed to this engineer
  month             String          // "2026-01" derived from BankTransaction.postedAt
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@unique([bankTransactionId, teamMemberId])
  @@index([teamMemberId, month])
  @@index([month])
}

model EngineerCostAllocation {
  id             String     @id @default(cuid())
  teamMemberId   String
  teamMember     TeamMember @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  customerId     String
  customer       Customer   @relation(fields: [customerId], references: [id], onDelete: Cascade)
  month          String     // "2026-01"
  ticketCount    Int        // Completed tickets by this engineer for this customer
  totalTickets   Int        // Total completed tickets by this engineer in this month
  percentage     Float      // ticketCount / totalTickets * 100
  attributedCost Float      // EngineerPayment.amount * (ticketCount / totalTickets)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  @@unique([teamMemberId, customerId, month])
  @@index([customerId, month])
  @@index([month])
}

model SystemProposal {
  id          String    @id @default(cuid())
  type        String    // "alias", "vendor_pattern", "domain_mapping", "suppression", "threshold"
  status      String    @default("pending") // "pending", "approved", "rejected"
  description String    // Human-readable description of what this proposal does
  evidence    String?   // JSON: the resolution decisions that triggered this proposal
  payload     String    // JSON: the rule data to apply if approved
  sourceItemId String?  // The resolution item that triggered this proposal
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?
  updatedAt   DateTime  @updatedAt

  @@index([status])
  @@index([type, status])
}

model SystemRule {
  id        String   @id @default(cuid())
  type      String   // "alias", "vendor_pattern", "domain_mapping", "suppression"
  source    String   // "proposal-approved", "user-created", "seed-data"
  payload   String   // JSON: the rule data (e.g. { customerId, alias } or { sourcePattern, targetId })
  isActive  Boolean  @default(true)
  hitCount  Int      @default(0) // How many times this rule has been used during matching
  lastHitAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, isActive])
}
